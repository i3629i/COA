## 1. 제어 유니트  
### 1.1 제어신호
* 내부로 보내는 제어 신호 - 레지스터로 데이터 전송, ALU연산
* 외부로 보내는 제어 신호 - 기억장치로 전송, I/O장치로 전송
* 제어 유니트로 들어오는 입력 - Flag, Clock, 명령어 레지스터, 외부 제어신호(인터럽트 같은)

### 1.2 마이크로 연산
* 가장 세분화된 프로세서기능
* 서브 사이클 보다 작은 단계에서 이루어지는 연산
* 순서대로 명령어 실행 - 명령어 사이클 - 서브 사이클(Fetch, Execute, Indirect, Interrupt) - 마이크로 연산

### 1.3 명령어 인출 사용을 위한 4가지 레지스터
PC, MBR, MAR, IR

### 1.4 명령어 인출 절차
t1 : MAR <- (PC) <br>
t2 : MBR <- Memory <br>
    PC<- PC+I(1) <br>
t3 : IR <- (MBR) <br> 그림생략

### 1.5 간접 사이클
t1 : MAR <- (IR(address)) <br>
t2 : MBR <- Memory <br>
t3 : IR <- (MBR(address)) <br>

### 1.6 인터럽트 사이클
t1 : MBR <- (PC) <br>
t2 : MAR <- save-address <br>
PC <- Routine-address <br>
t3 : Memory <- (MBR) <br>
MAR에는 저장할 위치 주소 적재, PC에는 루틴 첫 시작 주소 적재

### 1.7 실행 사이클 : ADD
ADD R1,X <br>
t1 : MAR <- (IR(address)) <br>
t2 : MBR <- Memory <br>
t3 : R1 <- R1 + (MBR) _(@ALU) <br>

### 1.8 실행 사이클 : ISZ
t1 : MAR <- (IR(address)) <br>
t2 : MBR <- Memory <br>
t3 : MBR <- (MBR) + 1 <br>
t4 : Memory <- (MBR) <br>
if (MBR) == 0 then PC <- PC + 1 <br>

### 1.9 BSA
t1 : MAR <- (IR(address)) <br>
MBR <- (PC(address)) <br>
t2 : PC <- (IR(address)) <br>
Memory <- (MBR(address)) <br>
t3 : PC <- PC + I <br>

## 2. 명령어 사이클
* ICC 00 == 인출, 01 == 간접, 10 == 실행, 11 ==인터럽트

## 3. 제어 유니트 기능
* 순서제어 - 제어 유니트는 순서를 의존성에 해소되게 해결함 
* 실행 - 

### 3.1 제어신호
* 제어 유니트를 수행하려면 시스템 상태를 정해주는 입력과 시스템 동작을 제어하는 출력이 필수적
#### 3.1.1 입력 신호
* flags
* Clock - 매 클록 펄스마다 하나의 마이크로 연산을 실행
* 명령어 레지스터
* 외부 제어신호 (인터럽트 같은)
#### 3.1.2 출력 신호
* 내부로 보내는 출력 - ALU나, 레지스터내의 데이터 이동의 제어신호 보냄
* 외부로 보내는 출력 - 기억장치나 I/O로 제어신호 보냄

### 3.2 제어 유닛 구성
명령어 레지스터 -> 명령어 해독기(시작 주소계산) -> 제어 주소 레지스터 -> 제어 메모리 -> 제어 버퍼 레지스터 -> 해독기 -> 시퀀스 로직 -> 제어 주소 레지스터

### 3.3 제어 기억장치
* 인출, 간접, 실행, 인터럽트 순서

### 3.4 제어유니트 동작 순서 요악
1. 명령어 레지스터의 연산코드를 해독기에 넣어 해독함 <br>
2. 해독후 시작주소를 통해 제어 서브 루틴의 시작주소를 계산함 <br>
3. Sequencing Logic에서 순서를 알기위해 Read명령을 제어메모리로 보냄 <br>
4. 제어 메모리에 있는 데이터를 CBR로 전송함 <br>
5. CBR에 있는 데이터를 해독해서 다음 시작주소를 찾음 <br>
6. Sequencing Logic를 통해 CBR과 flag를 통해서 CAR로 주소를 적재함 <br>

### 3.5 마이크로 프로그램 제어 방식
명령어 레지스터 -> 연산코드 -> 제어메모리 안의 마이크로 프로그램에서의 제어 서브루틴으로 들어감(인출 간접 실행 인터럽트 순) -> 마이크로 명령어 -> 마이크로 연산 필드로 감 -> 제어신호 출력
<br>
* 연산코드를 이용해서 기억장치 내의 해당 제어 서브루틴의 시작 주소를 찾음

### 3.6 마이크로 명령어 형식
연산필드1, 연산필드2, 조건, 분기, ADF주소필드

### 3.7 수평적 마이크로 명령어 vs 수직적 마이크로 명령어
* 수평적 마이크로 명령어 - 각 비트에 대응하여 제어신호가 필요함 8비트면 8개의 제어신호, 병렬성이 강하다 병렬용이, 
* 수직적 마이크로 명령어 - 해독기 장치가 별도로 필요, 적은 비트로 여러 제어신호 표현 가능 Log2 3비트면 8개 표현 가능함, 코드화된 비트, 병렬처리에 제약이 있음, 수평적 보다 간단한 구성
