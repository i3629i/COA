### 1. 프로세스에게 요구되는 업무
* 명령어 인출
* 명령어 해독
* 데이터 인출
* 데이터 처리
* 데이터 쓰기
#### 1.1 일을 처리 하기 위해 내부 레지스터가 필요하다.

### 2. 레지스터 조직
* 레지스터는 최상위 기억장치
* 레지스터가 많을 수록 일을 빠르고 효과적으로 처리
#### 2.1 레지스터의 역할
1. 사용자에게 보이는 레지스터 - 주기억장치의 사용을 최소화 하려고 노력
* 일반 목적용 레지스터 - 명령어가 길고 복잡하다, 융통성과 프로그래머 옵션이 증가 한다.
* 주소
* 데이터
* flags
2. 제어 및 상태 레지스터 - 동작을 제어하는 제어유니트와 프로그램 실행을 제어하는 운영체제 프로그램에 의해 사용됨
* PC(Program Counter) - Skip/분기 명령어도 갱신 시킨다, 다음 실행할 명령어의 주소
* IR(Instruction Register) - 최근에 인출한 명령어를 보관하는 레지스터
* MBR(Memory Buffer Register) - CPU내의 기억장치에서 보낸 데이터를 보관하는 레지스터, 데이터 버스를 통해 이동
* MAR(Memory Address Gegister) - CPU의 PC의 주소를 기억장치 참조전에 보관하는 레지스터, 주소 버스를 통해 이동

#### 2.2 일반 목적용 vs 특수 목적용
* 일반 목적용 레지스터 - 명령어가 길고 복잡하다, 융통성과 프로그래머 옵션이 증가
  * 레지스터의 개수는 8~32개
  * 레지스터가 많을수록 주기억장치 잠조를 덜해도 되지만 레지스터가 적을 수록 기억장치 참조가 증가한다.
  * 레지스터가 많을수록 더 많은 수의 오퍼랜드 오퍼랜드 지정자 비트 요구
  * 주소 레지스터는 가장 긴 주소를 저장 할 수 있을 만큼 레지스터가 커야한다.
  * 데이터 레지스터는 유형별로 있는 데이터를 저장 할 수 있을 만큼 커야한다.
* 특수 목적용 레지스터 - 명령어가 간결하지만, 유연성이 낮다
* Risc구조는 일반 목적용 레지스터, Cisc구조는 특수 목적용 레지스터(Intel사용)

### 3. 프로그램 상태 단어(PSW)
flag - 프로그램의 상태를 저장하는 비트 이다 ex)sign, zero, equal, supervisor

### 4. 간접 사이클 
* 간접 주소지정시 기억장치의 액세스가 한번 더 필요하다.
* 간접 주소 지정도 인출도 하나의 명령어 단계로 간주한다.
* Fetch <-> Execute 
* Fetch > Indirect > Execute > Interrupt > Fetch

### 5. 명령어 파이프라이닝
2단계 명령어 파이프라이닝 - 명령어가 주기억장치를 액세스 하지 않는 시간에 다음 실행할 명령어를 미리 가져오는 기법
파이프라이닝 - 미리 가져와서 명령어를 올려놈

#### 5.1 파이프 라이닝의 속도의 한계
* 실행하는 시간이 인출시간 보다 훨 씬 느리다.
* 자원이 출동하게 된다.(구조적인 문제)
* 분기가 일어날 시에 분기 명령어의 실행 주소를 모른다.
* 같은 파이프라인 내의 명령어에서 데이터의 내용이 다르게 될 수 있다.(데이터가 저장 되기 전에 오퍼랜드 에서 가져올 때)

#### 5.2 파이프 라인 시간
표현하기 힘드니 타우 = a
* 한 단계에서 명령어가 실행되는 최대시간
* a = a_max + d, a_max는 명령어 단계에서 실행 될 때 걸리는 최대시간, d는 명령어가 다음 단계로 넘어 갈 때 걸리는 시간
* n개의 명령어를 가진 파이프라인이 걸리는 전체시간
* T(k,n) = [k + (n-1)]a, k는 명령어의 단계 수, n은 명령어 개수
* 성능 평가
* T(1,n)/T(k,n) 구함

#### 5.3 6단계 파이프라이닝 구조
* FI -> DI -> CO -> 조건분기? (if == Yes), PC업데이트 -> Pipe Empty -> FI
* FI -> DI -> CO -> 조건분기? (if == NO), FO -> EI -> WO -> 분기 or 인터럽트 -> yes면 pc업데이트로 NO면 FI로

#### 5.4 파이프라이닝에 따른 속도 향상
* 명령어의 개수가 많아 질 수록 K배의 속도가 향상
* 파이프라인의 명령어의 단계가 많아 질 수록 속도 향상

#### 5.5 파이프라인 해저드(자원(구조적)해저드, 데이터 해저드, 분기(제어) 해저드)
* 자원 해저드(구조적 해저드)
  * 파이프 라인에 들어와 있는데 구조적으로 동시에 기억장치에서 데이터를 참조 시키려 할 때 기억장치를 이용
  * 구조적인 문제
  * 자원해저드의 결과 병렬이 아닌 직렬로 수행 한다.
  * 기억장치와의 통신포트가 한 개만 있다고 가정, ALU도 한개
  * 해결방안은 자원을 늘린다 ex) ALU를 증가시키거나, 통신 포트를 여러개를 둔다.
  
* 데이터 해저드
  * 오퍼랜드의 액세스위치에 대한 충돌
  * 명령어 두개가 같은 파이프라인에 실행 된 결과 값이, 순차적으로 처리한 결과와 다른 값이 될 수 있음.
  * 명령어가 2개 있는데 둘 다 같은 데이트를 쓴다고 가정하였을때 앞의 명령어가 WO전에 뒤의 명령어가 FO를 하게되면 갱신 되지 않은 상태에서 데이터를 가져오게됨
  
* 제어 해저드
 * 파이프 라인의 조건분기에 대한 예측에 결정을 잘못해, 다음 값들이 쓰레기 값들이 남아 있을 때
 * 조건 분기를 처리하는 방법
1. 다중 열 - 분기 결과에 나타나는 두 개의 명령어를 인출 하여 열에 모두 올려놈. , 경합이 발생 할 수 있음, 
2. 분기 목적지 선인출 - 분기를 인출 할 때 분기의 목적지도 인출하여 보관 해놓음.
3. 루프 버퍼 - 분기 명령어 캐시를 이용하여 분기 목적지가 버퍼에 있으면 가져다 사용(캐시같은 원리) 
4. 분기예측 - 분기가 일어나지 않음예측, 분기 일어남 으로 예측, 코드를 분석해 분기 예측, 분기 발생/미발생 스위치

### 6. 수퍼 스칼라
* 여러 개의 파이프라인에서 독립적으로 명령을 실행하는
* 병렬성을 제공 하여 수행,  그러나 프로그램의 결과가 순차적으로 실행하는 것과 다르지 않아야 함, 순서와 다르게 실행
* 정수연산 파이프라이닝 따로 부동소수점 연산 파이프라이닝 따로 의존성이 없어야함
* 명령어간 의존성이 없어야함 독립적인 명령어 수행
* 병렬성을 유지하기 위해 컴파일러의 최적화와 하드웨어의 자원을 같이 사용

#### 6.1 의존성
* 자원 충돌 - 같은 시스템 버스 사용시 
* 데이터 의존성 - 명령어 끝나기 전에 같은 데이터 사용 X
* 프로시저 의존성 - 분기가 일어날 시에 맞춰서 대기를 해줘야함

#### 6.2 명령어 수준 병렬성 and 기계 병렬성
* 명령어 수준 병렬성 - 명령어 수준 병렬성은 데이터 수준 의존성과 프로시져 의존성에 실행 빈도에 따라서 결정된다.
* 기계 병렬성 - 기계 병렬성은 프로세서가 명령어 수준 병렬성을 얼마나 활용 할 수 있는지 나타내는 척도 이다. 동시에 인출해 실행 할 수 있는 수와 프로세서가 독립적인 명령어를 찾기 위한 속도

#### 6.3 수퍼스칼라 프로세서의 성능 향상 방안
* 자원의 중복
* 명령어 순서 변경(명령어 윈도우) - 명령어의 순서를 바꾸어 종료하고 수행 하는 것 명령어 윈도우
* 레지스터 재명명 - 레지스터의 이름을 바꾸어서 충돌을 방지

#### 6.4 수퍼스칼라 기반 명령어 실행
* 실행될 프로그램은 순차적 배열로 구성되어 있음
* 명령어는 인출 과정을 통해서 명령어들이 동적흐름을 형성함
* 이 명령어들을 실행윈도우로 발송
* 프로세서는 실제 데이터 의존성 과 하드웨어의 자원 사용 가능성에 의해 결정된 순서에 명령어 실행
* 명령어 들은 개념적으로 다시 순차적으로 돌아옴, 결과는 기록 됨.

#### 6.5 하드웨어 지원
* 의존성 결정 회로
* 여러개의 물리적인 파이프 라인
